"""demultiplex.py demultiplex sequencing reads."""

import argparse
import re
import shlex
import subprocess as sp
import sys
import xml.etree.ElementTree as ET

import numpy as np
import pandas as pd

from interop import summary

from .utils.pathutils import PathLike, parse_path


# FIXME: move to config module!!!
TAKARA_PRIMER_MAP = "/mnt/BioPipeline/resource/Hsapien/GRCh38/general/takara_primer_map.tsv"
PICARD = "/home/simo/opt/bin/picard.jar"


def get_runsummary(interop_dir: PathLike) -> pd.DataFrame:
    """Get 4 run summary metrics generated by Illumina sequence control software.

    The metrics returned are as follows:

    ====================== ================================================================================
    Name                   Definition
    ====================== ================================================================================
    Total yiled            Total yield from a run
    > Q30%                 Percentage of bases with a quality score of 30 or higher
    Fraction of cluters pf Fraction of clusters passing Illumina Chastity filter (clear signal in the base)
    Cluster density        Density of clusters in thousands per mm^2
    ====================== ================================================================================

    Args:
        interop_dir: path to interop directory.

    Returns:
        Summary stats.

    """
    total = summary(str(interop_dir), level="Total")
    read = summary(str(interop_dir), level="Lane")

    return pd.DataFrame.from_dict(
        {
            "total_yield": np.float64(total["Yield G"]),
            "bases_gt_q30": np.float64(total["% >= Q30"] / 100),
            "clusters_frac_pf": [sum(read["Cluster Count Pf"]) / sum(read["Cluster Count"])],
            "cluster_density": np.average(read["Density"]) / 1000,  # type: ignore  # incomplete numpy typing
        }
    )


def run_IlluminaToFastq(param_df: pd.DataFrame, args: argparse.Namespace) -> None:
    """Run demultiplex step, converting bcl to fastq reads."""
    basecall_dir = args.run_dir / "Data/Intensities/BaseCalls"
    if not basecall_dir.exists():
        print(f"[ERROR]: cannot find the basecall directory {basecall_dir}")
        sys.exit(1)

    run_info_xml = args.run_dir / "RunInfo.xml"
    if not run_info_xml.exists():
        print("[ERROR]: cannot find the RunInfo.xml")
        sys.exit(1)

    # get run information
    print("[INFO]: getting instrument SN, flowcell barcode, run number from RunInfo.xml")
    tree = ET.parse(run_info_xml)
    root = tree.getroot()
    run = root.find("Run")
    if run is None:
        print("[ERROR]: failed to get run from RunInfo.xml")
        sys.exit(1)

    run_barcode = run.attrib["Number"]
    if not run_barcode:
        print("[ERROR]: failed to get run number from RunInfo.xml")
        sys.exit(1)

    fc = run.find("Flowcell")
    flowcell = fc.text if fc is not None else None
    if not flowcell:
        print("[ERROR]: failed to get flowcell barcode from RunInfo.xml")
        sys.exit(1)

    instrument_name = run.find("Instrument")
    instrument = instrument_name.text if instrument_name is not None else None
    if not instrument:
        print("[ERROR]: failed to get instrument SN from RunInfo.xml")
        sys.exit(1)

    run_name = args.run_dir.name
    if not run_name:
        print("[ERROR]: failed to get run name from provided --run_dir value")
        sys.exit(1)

    out_dir = args.out_dir / run_name / "Fastq"
    out_dir.mkdir(parents=True, exist_ok=True)

    barcode_df = param_df.copy(deep=True)
    barcode_df.columns = [
        "library_name",
        "barcode_sequence_1",
        "barcode_sequence_2",
        "barcode_sequence_3",
        "barcode_name",
    ]
    barcode_df = barcode_df[barcode_df.library_name != "Undetermined"]
    barcode_file = out_dir / f"{run_name}.demultiplex.barcodes.tsv"
    barcode_df.to_csv(barcode_file, sep="\t", index=False)
    metric_file = out_dir / f"{run_name}.demultiplex.barcodes.metrics.txt"
    param_df.drop("barcode_name", axis=1, inplace=True)
    param_df.loc[:, "OUTPUT_PREFIX"] = out_dir / param_df.OUTPUT_PREFIX
    param_file = out_dir / f"{run_name}.demultiplex.params.tsv"
    param_df.to_csv(param_file, sep="\t", index=False)

    done_file = out_dir / f"{run_name}.demultiplex.done"
    if not done_file.exists():
        cmd = (
            "java -jar {} ExtractIlluminaBarcodes MAX_MISMATCHES={} BASECALLS_DIR={} "
            "LANE=1 READ_STRUCTURE={} BARCODE_FILE={} METRICS_FILE={} NUM_PROCESSORS={}".format(
                PICARD,
                args.max_mismatch,
                basecall_dir,
                args.readstructure,
                barcode_file,
                metric_file,
                args.n_cores,
            )
        )
        print("[INFO]: Running PICARD ExtractIlluminaBarcodes")
        extract_stdout = out_dir / f"{run_name}.demultiplex.barcodes.extract.stdout"
        extract_stderr = out_dir / f"{run_name}.demultiplex.barcodes.extract.stderr"
        try:
            p = sp.Popen(
                shlex.split(cmd),
                stdout=open(extract_stdout, "w"),
                stderr=open(extract_stderr, "w"),
            )
            p.communicate()
            rcode = p.returncode
            if rcode != 0:
                print("[ERROR]: Running ExtractIlluminaBarcodes Failed")
                print(f"[ERROR]: Please refer to {extract_stderr} for detail")
                sys.exit(1)
        except (OSError, ValueError) as e:
            print(f"[ERROR]: Running ExtractIlluminaBarcodes Failed {e}")
            sys.exit(1)
        print("[INFO]: Running PICARD ExtractIlluminaBarcodes [DONE]")

        print("[INFO]: Checking demultiplex metrics")
        extract_res_df = pd.read_csv(metric_file, sep="\t", comment="#")
        n_undetermined = int(extract_res_df[extract_res_df.BARCODE_NAME.isnull()].READS)
        n_throughput = np.sum(extract_res_df[~extract_res_df.BARCODE_NAME.isnull()].READS)
        frac_undetermined = n_undetermined / (n_throughput + n_undetermined)
        print(f"[INFO]: The fraction of undetermined is {frac_undetermined}")
        if frac_undetermined > args.min_undetermined_frac:
            print("[WARNING]: The fraction of undetermined is beyond the minimum allowed")
            print(
                "[WARNING]: If you still want to have Fastqs, " "please set a higher value of --min_undetermined_frac",
            )
            sys.exit(1)
        print("[INFO]: Checking demultiplex metrics [DONE]")

        cmd = (
            "java -jar {} IlluminaBasecallsToFastq BASECALLS_DIR={} LANE=1 READ_STRUCTURE={} "
            "MULTIPLEX_PARAMS={} MACHINE_NAME={} RUN_BARCODE={} FLOWCELL_BARCODE={} "
            "COMPRESS_OUTPUTS=true NUM_PROCESSORS={}".format(
                PICARD,
                basecall_dir,
                args.readstructure,
                param_file,
                instrument,
                run_barcode,
                flowcell,
                args.n_cores,
            )
        )
        print("[INFO]: Running PICARD IlluminaBasecallsToFastq")
        tofq_stdout = out_dir / f"{run_name}.demultiplex.illuminatofq.stdout"
        tofq_stderr = out_dir / f"{run_name}.demultiplex.illuminatofq.stderr"
        try:
            p = sp.Popen(
                shlex.split(cmd),
                stdout=open(tofq_stdout, "w"),
                stderr=open(tofq_stderr, "w"),
            )
            p.communicate()
            rcode = p.returncode
            if rcode != 0:
                print("[ERROR]: Running IlluminaBasecallsToFastq Failed")
                print(f"[ERROR]: Please refer to {tofq_stderr} for detail")
                sys.exit(0)
        except (OSError, ValueError) as e:
            print(f"[ERROR]: IlluminaBasecallsToFastq Failed {e}")
            sys.exit(1)
        # touch done file
        done_file.touch(mode=0o644, exist_ok=True)  # rw-r--r--
        print("[INFO]: Running PICARD IlluminaBasecallsToFastq [DONE]")
    else:
        print("[INFO]: Found previous results... Skip")
        print(f"[INFO]: To rerun, please remove the done file {done_file}")


def rc(row: pd.DataFrame, tr_map: dict[str, str]) -> pd.DataFrame:
    """Get reverse complmmenet of the FwdPCTPrimer sequence."""
    print("rc from demultiplex.py")
    print(type(row))
    print(type(tr_map))
    row["BARCODE_2"] = row["BARCODE_2"][::-1].translate(tr_map)
    return row


def run_demultiplex(args: argparse.Namespace) -> None:
    """Run demultiplex."""
    if not args.metasheet.exists():
        print(f"[ERROR]: cannot find the provided metasheet {args.metasheet}")
        sys.exit(1)

    if not args.run_dir.exists():
        print(f"[ERROR]: cannot find the provided basecall directory {args.run_dir}")
        sys.exit(1)

    takara_map = parse_path(TAKARA_PRIMER_MAP)
    if not takara_map.exists():
        print(f"[ERROR]: cannot find the Takara primer map file {takara_map}")
        sys.exit(1)

    metasheet_df = pd.read_csv(args.metasheet, sep="\t")
    metasheet_df.loc[:, "SampleName"] = metasheet_df.SampleName.apply(lambda x: re.sub("_", "-", x))

    primer_map_df = pd.read_csv(takara_map, sep="\t")

    # this is not general at all
    print("[INFO]: matching primer IDs and extracting primer sequences")
    metasheet_df = pd.merge(
        metasheet_df,
        primer_map_df,
        how="left",
        left_on="RevPCRPrimer",
        right_on="PrimerID",
    )
    metasheet_df = pd.merge(
        metasheet_df,
        primer_map_df,
        how="left",
        left_on="FwdPCRPrimer",
        right_on="PrimerID",
    )
    metasheet_df = pd.merge(
        metasheet_df,
        primer_map_df,
        how="left",
        left_on="InLineBarcode",
        right_on="PrimerID",
    )
    metasheet_df.loc[:, "barcode_name"] = (
        metasheet_df.RevPCRPrimer + "_" + metasheet_df.FwdPCRPrimer + "_" + metasheet_df.InLineBarcode
    )

    multiplex_param_df = metasheet_df.loc[
        :,
        [
            "SampleName",
            "barcode_sequence_1_x",
            "barcode_sequence_1_y",
            "barcode_sequence_1",
            "barcode_name",
        ],
    ]
    multiplex_param_df.columns = [
        "OUTPUT_PREFIX",
        "BARCODE_1",
        "BARCODE_2",
        "BARCODE_3",
        "barcode_name",
    ]
    # now need to check if any barcode sequence columns have NAs
    multiplex_param_df.loc[:, "NaOrNot"] = multiplex_param_df[["BARCODE_1", "BARCODE_2", "BARCODE_3"]].isnull().any(1)
    na_check = np.any(multiplex_param_df.NaOrNot)
    if na_check:
        print("[ERROR]: some barcode sequences are NAs")
        print(f"[ERROR]: please check whether the primer ID matches the ones in the {takara_map}")
        print(multiplex_param_df[multiplex_param_df.NaOrNot])
        sys.exit(1)
    multiplex_param_df.drop("NaOrNot", axis=1, inplace=True)

    print("[INFO]: reversing and complementing the forward primer sequences")
    multiplex_param_df = multiplex_param_df.apply(rc, axis=1, args=(str.maketrans("ACGT", "TGCA"),))
    # adding in undetermined sample
    undetermined_df = pd.DataFrame(
        {
            "OUTPUT_PREFIX": ["Undetermined"],
            "BARCODE_1": ["N"],
            "BARCODE_2": ["N"],
            "BARCODE_3": ["N"],
            "barcode_name": ["N"],
        },
    )
    multiplex_param_df = pd.concat([multiplex_param_df, undetermined_df], ignore_index=True, axis=0)

    run_IlluminaToFastq(multiplex_param_df, args)


def run_analyze(args: argparse.Namespace) -> None:
    """Run analysis."""
    pass


def parse_cmd() -> argparse.Namespace:
    """Parse commands."""
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(title="Commands", metavar="", dest="command")
    demultiplex = subparsers.add_parser("demultiplex", description="Demultiplex")
    demultiplex.add_argument(
        "--metasheet",
        metavar="FILE",
        dest="metasheet",
        type=parse_path,
        required=True,
        help="specify the RNA metasheet",
    )
    demultiplex.add_argument(
        "--rundir",
        metavar="DIR",
        dest="run_dir",
        type=parse_path,
        required=True,
        help="specify the sequencing run folder",
    )
    demultiplex.add_argument(
        "--outdir",
        metavar="DIR",
        dest="out_dir",
        type=parse_path,
        required=True,
        help="specify the output directory",
    )
    demultiplex.add_argument(
        "--readstructure",
        metavar="STR",
        dest="readstructure",
        default="120T8B8B6B24T",
        type=str,
        help="specify the read structure (120T8B8B6B24T)",
    )
    demultiplex.add_argument(
        "--max_mismatch",
        metavar="INT",
        dest="max_mismatch",
        default=2,
        type=int,
        help="specify the maximum number of mismatches allowed (2)",
    )
    demultiplex.add_argument(
        "--min_undetermined_frac",
        metavar="FLOAT",
        dest="min_undetermined_frac",
        default=0.2,
        type=float,
        help="specify the minimum fraction of undetermined beyond which no fastqs will be generated (0.2)",
    )
    demultiplex.add_argument(
        "--cores",
        metavar="INT",
        dest="n_cores",
        default=4,
        type=int,
        help="specify the number of cores (4)",
    )
    demultiplex.set_defaults(func=run_demultiplex)

    analyze = subparsers.add_parser("analyze", description="Analyze undetermined [not implemented]")
    analyze.add_argument(
        "--in_dir",
        metavar="DIR",
        dest="in_dir",
        type=parse_path,
        required=True,
        help="specify the directory where undetermind barcodes files can be found",
    )
    analyze.set_defaults(func=run_analyze)

    return parser.parse_args()


def main() -> None:
    """Run demuliplex."""
    args = parse_cmd()
    args.func(args)


if __name__ == "__main__":
    main()
